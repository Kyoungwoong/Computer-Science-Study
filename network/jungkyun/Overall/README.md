# 🌐 Overall (네트워크)

## Link Layer(링크 계층)

### Link Layer의 역할

링크계층은 두 개의 인접한 네트워크 장치 간의 데이터 전송을 담당하며 주로 NIC(Network Inteface Card)의 형태 또는 칩셋의 형태로 하드웨어에 구축이 되어있다.

물리적으로 직접 연결된 장치 간에 동작하며, 데이터는 이러한 연결을 통해서 `프레임 단위`로 전달된다.

`Sender` 측에서는 상위계층으로부터 받은 데이터그램(IP 패킷)을 `프레임` 이라는 단위로 캡슐화한다.

프레임에는 아래와 같은 정보가 포함된다.
- 헤더 정보 (MAC 주소 등)
- 데이터 (IP datagram)
- 에러 검출 정보 (CRC 등의 checking bit)

`Receiver` 측에서는 프레임을 수신하고 에러 검출을 통해 데이터에 문제가 없는 지 확인한 후에 유효한 경우 IP 데이터그램을 추출해서 상위 계층으로 전달한다.

---

### Link Layer 서비스

링크 계층은 `hop-to-hop`, 즉 인접 노드 간의 신뢰성을 보장한다.

이러한 신뢰성을 보장하는 것은 `이더넷`이나 `광케이블`같은 에러율이 매우 낮은 링크에서는 굳이 제공할 필요가 없지만 `Wi-Fi` 같은 에러율이 높은 링크에서는 매우 유용하다.

그러면 TCP와 뭐가 다른가?

위에서 말했다시피 링크계층은 `hop-to-hop`을 보장하지만 TCP는 `end-to-end` 신뢰성을 보장하게 된다. 따라서 TCP는 송신지와 수신지의 Application 레벨에서 재전송, 흐름제어, 혼잡제어 등을 담당하게 되며 링크 계층은 로컬에서 에러를 수정하여 한 홉 단위에서 재전송해주면, 에러가 상위 계층까지 올라가지 않으니깐 더 효율적이게 사용할 수 있다.

> ### 이렇게 되면 또 하나만 쓰면 되는거 아닐까,, 둘 다 필요한가?

위의 질문에 대한 답은 **"그렇다"** 이다.

일단 TCP가 있음에도 Link Layer가 존재하는 이유는 로컬에서 고치면 패킷이 멀리까지 갔다가 재전송할 필요가 없어지기 때문에 빠르고 효율적이기 때문이다.

그러나 링크 계층만으로는 전체 경로에서 손실되는 경우, 예를 들어 라우터 큐의 오버플로우 등을 막을 수 없기 때문에 TCP 같은 `end-to-end reliability` 또한 필요하다.

---

### Error Detection

> ### LinkLayer 에서 에러는 왜 발생할까?

에러는 `신호 감쇠(Signal attenuation)`, 또는 `잡음(noise)` 때문에 발생한다.

두 원인 모두 전송 중에 발생하는 에러이기 때문에 에러가 발생하면 수신측에서 프레임을 검사해서 에러를 감지해야 한다.

송신측이 에러를 감지하면 재전송을 요청하는 `ARQ`, 또는 그냥 프레임을 드롭 중 하나로 처리한다.

#### Parity Checking(Simplest Error Detection)

에러를 검출하는 가장 간단한 방법으로 `Parity Checking` 방법이 있다.
![alt text](ParityBit.png)

위와 같은 그림처럼 DataFrame에 존재하는 `1`의 개수를 세서 1의 개수가 항상 짝수 또는 홀수가 되게 맞춰주는 과정이다. 

만약 짝수개로 설정을 해놨다면, 수신측에서 홀수개의 1이 있다면 오류가 있다는 것을 알 수 있다.

그러나 이것에 대한 문제점은 뭘까?

생각을 좀만 해보면 알겠지만 이 오류 검출 방식은 **에러가 발생했는지 여부**만 확인하기 때문에 수정은 불가하고, 단순히 **에러 감지용**이다.

또한 짝수개의 비트가 오류가 나서 서로 상쇄가 된다면 오류가 없다고 하고 넘어가는 불상사가 발생하게 된다.

> ### 그럼 2차원으로 해보면 되는거 아닌가?

아까 1차원으로 한 것보다 더 강력한 에러 검출 능력과 수정 가능성을 제공한다.

데이터 블록을 행과 열로 배열하고, 각 행마다 가로 Parity bit, 각 열마다 세로 Parity bit를 추가하는 방식이다.

아래 그림은 내가 짝수개로 맞춘다는 가정을 하고 2차원으로 오류를 검출한다고 해보자.

```
1 0 1 0 1  1   ← 행 패리티
1 0 1 1 0  0   ← ❌ 3 + 0 != 짝수 오류 발생!!
0 1 1 1 0  1
---------
0 0 1 0 1  0   ← 열 패리티
```

2번 행과 2번 열에서 오류가 검출되었다는 것을 알 수 있다. 이런 방식으로 어디서 오류가 발생했는지를 탐색을 해서 수정을 할 수 있게 되었다.

그러나 아래와 같은 상황을 가정해보자.

```
원래:
1 0 1 0 1   1
0 1 1 1 0   1
1 1 0 0 1   1

세로 패리티:
0 0 0 0 0
```

```
변경 후:
0 0 0 0 1   1
0 1 1 1 0   1
1 1 0 0 1   1
```

이렇게 되면 여전히 짝수로 유지가 되기 때문에, 에러검출을 실패하게 된다.

이러하듯 2차원 또한 짝수 개의 에러가 같은 행 또는 같은 열에서 발생하면 검출할 수 없다.

---

#### FEC (Forward Error Correction)

FEC는 데이터를 수신하는 측에서 오류감지 및 수정을 모두 할 수 있게 하는 것이다.

FEC를 사용함으로 송신측의 재전송하는 횟수를 줄일 수 있고, 에러를 바로 수종할 수 있다.

에러가 주로나는 무선 네트워크에서 사용하며 스트리밍에서 효율적으로 사용한다.

그 이유는 스트리밍은 실시간으로 끊김 없이 영상을 재생하는 것이 중요한데, 데이터에 오류가 생겨 재전송을 요청하고 기다리면 버퍼링이 발생하기 때문이다.

FEC를 사용하면 데이터 전송 전에 미리 오류 수정 정보를 추가하기 때문에, 수신 측에서 오류가 발생하더라도 재전송 요청 없이 스스로 오류를 복구할 수 있다.

---

#### CRC (Cyclic Redundancy Check)

지금까지 위에서 말했던 Parity Checking이나 FEC보다 강력한 에러 검출 방법이다.

원본 데이터(D)가 d-bit data라고 하면, CRC는 이 원본 데이터 뒤에 CRC 코드의 길이만큼 0을 추가한다.

송신측에서는 원본데이터에 0이 추가된 식을 `generator`라고 부르는 비트 패턴으로 나누고, 그 나머지를 CRC 코드라고 부르며 이 CRC 코드를 원본 데이터 D 뒤에 붙여서 전송한다.

수신측에서는 수신된 데이터 D + CRC 전체를 아까 나눈 똑같은 `generator`로 나누고, 나머지가 0이면 오류가 없다고 판단하고, 나머지가 0이 아니면 오류가 발생했다고 판단하고, 재전송을 요청한다.

```
        101011
     ----------
1001)101110 000
     1001
     ----
       101      
       000
       ----
       1010
       1001
       ------
         110
         000
         ------
         1100
         1001
         -------
          1010
          1001
          ------
            001 <- 이 부분이 나머지
```

### MAC address

맥주소는 그냥 기기가 고유하게 가지고 있는 48-bit 주소이다. 즉, 전 세계에 있는 모든 네트워크 장비는 서로 다른 MAC 주소를 가지고 있다.

이러한 MAC주소는 로컬 네트워크에 내에서 통신할 때 사용되며 지금까지 우리가 공부했듯이 다른 네트워크로 데이터를 보내기 위해서는 IP주소가 필요하고, MAC주소는  IP 주소를 통해 최종 목적지를 찾아가는 과정에서 사용된다.

#### MAC address vs IP address

IP주소는 계층적인 주소를 가지지만 MAC주소는 flat한 구조를 가진다.

> ### 계층적인 주소가 뭐지..?

말이 어려워보이긴 하지만 이미 다 아는 내용이다. IP 주소는 **네트워크 주소**와 **호스트 주소** 이렇게 두 부분으로 나뉜다. 이렇게 구분이 되어있기 때문에 IP주소를 효율적으로 관리하고, 라우터는 네트워크 주소만 보고 어느 방향으로 보낼지 결정할 수 있다.

> ### 그렇다면 MAC주소의 flat한 구조는 뭐지?

그냥 평면적으로 단일 식별자라는 뜻이다. 앞에 24bit는 장치를 만든 제조사를 나타내며, 뒤의 24bit는 해당 제조사가 부여한 고유한 일련번호를 뜻한다.

이 MAC주소만 보고 "어? 이 MAC주소면 어디에 위치해있겠는데?" 를 알 수 없다. 쉽게 예를 들자면 주민등록번호만 안다고 그 사람이 어디 사는지 알 수 없다는 뜻이다.

> ### 그러면 MAC주소 안쓰고 IP주소만 쓰면 안되나요..?

대답은 "안된다" 이다.

IP주소만으로는 통신이 불가능하다.
컴퓨터가 같은 네트워크에 있는 다른 컴퓨터와 통신한다고 해보자. IP주소는 "어디 네트워크에 속해 있다" 라는 정보만 포함하고 있기 때문에, 같은 네트워크내에서 패킷을 전달하려면 실제 장치를 식별하는 물리적 주소인 MAC주소가 필요하다.

또한 IP주소는 소프트웨어적으로 할당된다. 만약에 IP 주소만으로 통신한다면, 하드웨어 장치들을 직접 식별하고 데이터 링크 계층에서 통신하기 위한 고유한 주소 체계가 없어진다.

그리고 아무리 IP프로토콜이 표준이라고는 하지만 네트워크 통신에서 IP를 안쓸수도 있는 상황이 있을수도 있다.(사실은 없다고 봐도 무방하긴 하다.)

#### MAC frame의 전송방법

어떤 호스트 `A` 가 같은 서브넷에 존재하는 `B`에게 frame을 전송하려고 한다고 해보자.

그러면 frame의 목적지는 `B`의 MAC address 일거고, B는 해당 프레임을 받고, 만약에 `C`가 받게 된다면 `C`는 해당 프레임을 버린다.

> ### 엥 목적지가 B인데 C가 어떻게 받아요?

여러 경우가 있긴 하지만, 브로드캐스트 개념은 Data Link Layer에서도 적용이 된다. 특정 호스트가 아닌 모든 호스트에게 전달되어야 하는 프레임이 있을 것이다. 이 경우 목적지 MAC 주소는 `FF:FF:FF:FF:FF:FF` 로 설정되며, 스위치는 이 프레임을 모든 프레임을 모든 포트로 전송하게 된다.

`C`는 이 프레임이 브로드캐스트용임을 알고 자신의 MAC주소와 다르더라도 프레임을 받아서 처리한다.

두번째로는, 처음 네트워크에 연결된 장비이거나, 스위치에 기록된 MAC주소 테이블이 초기화된 경우, 스위치는 해당 호스트의 MAC주소를 모르기때문에, 스위치는 프레임을 보낸 포트를 제외한 모든 포트로 프레임을 전송하는데 이를 **Flooding** 이라고 한다. 

> ### 브로드캐스팅이랑 Flooding이랑 같은거 아닌가요?

비슷해보이지만 발생하는 이유와 목적이 다르다.

브로드캐스팅은 통신 방식이고, 플러딩은 스위치의 학습 동작이다.

#### DHCP에서의 MAC주소 역할

IP주소의 할당 과정은 DHCP에서 `DORA` 과정을 거쳐서 할당이 된다. 이 과정에서 MAC주소 또한 사용이 된다.

1. DHCP Discover (발견)<br>새로운 장비(클라이언트)가 네트워크에 연결되면, IP 주소를 받기 위해 DHCP Discover 메시지를 네트워크 전체에 브로드캐스트로 전송하는데 이때 메시지에 클라이언트 자신의 MAC 주소가 포함되어 있다.

2. DHCP Offer (제안)<br>DHCP Discover 메시지를 받은 DHCP 서버는 자신이 가지고 있는 IP 주소 중 사용 가능한 주소와 서브넷 마스크, 게이트웨이 등의 정보를 포함하여 클라이언트에게 DHCP Offer 메시지를 보낸다. 이 메시지에는 "이 IP 주소는 MAC 주소 (클라이언트의 MAC 주소)를 가진 장비를 위한 거야" 라는 정보가 담겨 있다.

3. DHCP Request (요청)<br>클라이언트는 여러 서버로부터 DHCP Offer를 받을 수 있으며, 그중 하나의 제안을 선택해 DHCP Request 메시지를 다시 브로드캐스트로 보내게 된다. 이 메시지에는 선택한 IP 주소와 자신의 MAC 주소가 포함되어 있습니다. 이렇게 브로드캐스트하는 이유는 다른 DHCP 서버들에게 "나 이 IP 주소를 사용할 거니까, 너희들이 제안한 건 거절할게"라고 알려주기 위함이다.

4. DHCP ACK (승인)<br>DHCP Request를 받은 서버는 최종적으로 해당 IP 주소를 할당한다는 DHCP ACK 메시지를 클라이언트에게 보낸다. 이 메시지 역시 클라이언트의 MAC 주소를 기반으로 전송되어, 정확히 해당 장비에게 최종 할당 정보를 전달한다.

#### ARP(Address Resolution Protocol)

ARP는 위에서 말한 DHCP의 반대되는 역할을 수행하는 프로토콜이다.

DHCP에서는 내 맥주소는 알지만 IP주소가 없어서 할당하는 과정이라면 ARP에서는 상대의 IP주소는 알지만 정확한 MAC주소를 모르기 때문에 그 MAC주소를 얻어오는 과정이다.

1. ARP 요청<br>호스트 `A`가 같은 네트워크에 있는 호스트 `B`에게 데이터를 보내려고 할때, IP주소는 알지만 MAC주소는 모른다. <br> 이때, `A`는 B의 IP주소(`192.168.1.10`)를 가진 호스트의 MAC주소가 뭐에요? 라는 메시지를 네트워크 전체에 **브로드캐스트**로 전송한다.

2. ARP 응답<br>네트워크의 모든 장치가 이 브로드캐스트 메시지를 받는다. `B`는 메시지의 IP 주소가 자신과 일치함을 확인하고, `A`에게 자신의 MAC주소를 담은 ARP응답 메시지를 보낸다. 이 응답은 **유니캐스트**로 전송된다.

3. ARP 캐시<br>`A`는 `B`로부터 받은 MAC주소를 ARP 캐시라는 임시 저장소에 저장하고, `B`와 통신할 때, 이 ARP캐시를 먼저 확인하여, ARP 요청을 다시 보낼 필요 없이 바로 MAC 주소를 사용해서 통신한다.

### Multiple Access Protocols

우리가 broadcast를 할 수 있는건 `multiple access`를 통해서 가능한 것이다.

`multiple access control protocol` 이란 여러 장치가 단일 공유 브로드캐스트 채널을 동시에 사용하려 할 때 발생하는 충돌을 제어하여 채널을 효율적으로 공유하기 위한 통신 규칙의 집합이다.

#### Channel Partitioning

MAC 프로토콜 중 하나이다.

이 방식은 이름 그대로 채널을 여러 개의 조각으로 나누어 각 장비에 전용으로 할당하는 방법이다. 이 조각을 나누는 기준은 시간(TDMA) 또는 주파수(FDMA) 또는 코드(CDMA)가 있다.

각 장비는 자신에게 할당된 조각만 사용하기 때문에, 다른 장비와 충돌이 발생할 가능성이 전혀 없다.

그러나, 트래픽이 적을 때도 할당된 채널을 다른 장비가 사용할 수 없어서 채널의 효율성이 떨어진다.

#### Random Access

이 방식은 채널을 나누지 않고, 모든 장비가 자유롭게 채널을 사용하기 위해 경쟁하는 방법이다.
각 장비는 데이터를 보낼 준비가 되면 즉시 전송을 시도하고, 이 때문에 `collision` 은 발생할 수 있다.

> ### 충돌이 나면 안좋은거 아닌가요...?

당연히 충돌이 나면 안되기 때문에 이 충돌을 감지하고, 회복할 수 있어야 한다.

그래서 나온 MAC protocol이 `CSMA`, `CSMA/CD`, `CSMA/CA` 등이 있다.

#### CSMA(Carrier Sense Multiple Access)

전송 전에 채널의 상태를 한번 듣고 전송하는 프로토콜이다.
만약에 채널이 조용하다고 판단되면, 전체 프레임을 전송하고, 채널이 바빠보인다면 전송을 미룬다.

그러나 여기서 문제가 생긴다.

두 장비가 동시에 채널이 조용하다 라고 판단을 하고 동시에 전송을 시작할 수도 있고, 전송되는 시간에 딜레이가 있기때문에 결과적으로는 충돌이 발생하는 것을 막을수는 없다. 

이를 해결하기 위해서 나온것이 CSMA/CD와 CSMA/CA이다.

#### CSMA/CD (Collision Detection)

일단 CarrierSense와 MultipleAccess 동작까지는 동일하게 진행된다.

이제 충돌감지인 Collision Detection을 해야하는데, 장비가 데이터를 전송하는 동시에 채널에서 발생하는 신호를 계속 모니터링 하게 된다.

만약 자신이 보낸 신호 외에 다른 신호가 감지되면, 충돌이 발생했다 라고 판단한다.

이러한 과정은 유선 네트워크에서는 전송과 수신이 동시에 가능하기 때문에 충돌 감지가 가능하지만, 무선에서는 수신되는 신호의 세기가 로컬의 전송 세기보다 약하기 때문에 충돌발생 감지가 힘들다.

> ### 실패하고 계속 전송하고, 실패하고 계속 전송할 수도 있는거 아닐까요?

그럴 수도 있다. 그렇기 때문에 충돌이 발생했을 때 재전송 시기를 결정하는 알고리즘인 `Binary Exponential backoff`라는 개념이 있다.

충돌이 발생하면, 충돌에 참여한 모든 장비는 무작위로 정해진 시간 동안 대기한 후 재전송을 시도하는데 이 대기 시간을 `backoff` 타임이라고 한다.

1. 초기 충돌<br>첫 충돌이 발생하면, 장비는 2^1을 기반으로 0부터 1 사이의 무작위 정수를 선택하고 백오프 타임은 이것에 비례하여 결정된다.

2. 두번째 충돌<br>재전송을 시도했는데 또다시 충돌이 발생하면, 백오오프 타임의 선택 범위가 두 배로 늘어난다. 이번에는 2^2를 기반으로 0부터 3 사이의 무작위 정수를 선택한다.

3. 반복<br>이와 같이 충돌이 계속될 때마다 백오프 타임의 선택 범위는 2^n 으로 기하급수적으로 늘어난다.

이렇게 지수적으로 반복하면서 재전송을 시도하는 장비들이 더 넓은 시간 범위에 분산되도록 유도하여, 충돌이 연속적으로 발생하는 것을 막아준다.

#### CSMA/CA (Collision Avoidance)

위에서 말했던것처럼 CD 방식은 무선에서 사용할 수 없고, 일단 가능하다 하더라고 신호를 보내면서 채널의 상태를 듣기에는 상대신호가 상대적으로 약할수밖에 없기때문에 그냥 피해버리는 전략인 CSMA/CA가 나왔다.

해당 방식 또한 CSMA과정은 그대로 진행한다.

만약에 channel 이 가용한 상태이면 곧바로 전송하는 것이 아니라, 짧은 시간동안 기다린 후 전송을 시작하는데 이 기다리는 시간은 주로 DIFS(Distributed Interframe Space)를 사용한다.

이 DIFS를 기다린 후에도 채널이 비어있으면, 장비는 무작위 `backoff` 타이머를 설정한다. 이 타이머가 0이 되고나서 전송을 시작한다. 이 과정은 여러 장비가 동시에 채널이 비었다 라는 판단을하고 전송하는 것을 막는 단계이다.

또한 CSMA/CD와 달리 CSMA/CA는 수신측으로부터 `ACK` 메시지를 받아서 전송 성공을 확인합니다. 만약 정해진 시간 내에 ACK를 받지 못하면, 충돌이 발생했거나 프레임이 손실되었다고 판단하고 백오프 후에 재전송합니다. 

#### Virtual Carrier Sensing
CSMA/CA에서 알아야할 개념이 또 잇는데 바로 `Virtual Carrier Sesing` 이다.

일반적인 Carrier Sensing과 다르게 무선 환경의 문제점을 해결하기 위해 고안된 개념이다.
간단히 설명을 하면 채널을 예약하는 방법이다.

먼저 데이터를 보내려는 장비가 지금부터 얼마동안 채널을 쓸거야 라는 짧은 신호를 보내는데 이것이 RTS(Request To Send) 이다.

이 RTS를 받은 AP는 주변의 모든 장비에게 이 채널이 언제까지 사용될 것인지 미리 알리는 신호인 CTS(Clear To Send)를 보낸다.

이 RTS/CTS 교환을 통해 네트워크의 모든 장비는 실제로 신호를 듣지 못하더라도, 향후 채널이 언제까지 사용될 것인지 미리 알게된다.