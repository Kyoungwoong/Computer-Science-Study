# 네트워크 총정리

## 어플리케이션 계층

### 📝 어플리케이션 계층 개요

---

* **프로세스 간 통신**에서 서버는 정보를 만들고 클라이언트는 그 정보를 받는다
* 여러 계층 가운데 **사용자와 가장 밀접**한 곳이 *어플리케이션 계층*이다

<br/>

### 🖥️ 서버 · 클라이언트

---

* **서버**는 24시간 클라이언트 요청을 기다린다
* **클라이언트**는 데이터가 필요할 때 서버에 요청을 보내고, 서버는 응답을 반환한다

<br/>

### 🔗 프로세스 간 통신

---

* **프로세스**는 실행 중인 프로그램을 의미한다
* 종류

  * **서버 프로세스** : 서버 OS 위에서 동작한다
  * **클라이언트 프로세스** : 클라이언트 OS 위에서 동작한다
* **Socket** 인터페이스

  * OS와 프로세스 사이 통신 창구 역할을 한다
  * 프로세스 간 통신 시 소켓에 바인드된 주소가 사용된다.

<br/>

### 🚚 TCP vs UDP

---

#### 🛡️ TCP (Transmission Control Protocol)

* **신뢰성**을 우선한다
* 특징

  * 3-way Handshake
  * **패킷 순서 보장 · 재전송 · 흐름 제어 · 혼잡 제어**
  * 손실·순서 오류 패킷을 복원한다
  * 속도는 상대적으로 느리다
* 사용 예시 : HTTP/HTTPS, SMTP, FTP

<!-- TCP 다이어그램 -->

![TCP 3-Way Handshake](img/tcp_3-way_handshake.jpg)

#### ⚡ UDP (User Datagram Protocol)

* **속도**를 우선한다, 비연결성이다
* 특징

  * Handshake가 없다
  * **순서·흐름·혼잡 제어가 없다**
  * 패킷 일부가 손실될 수 있다
  * 오버헤드가 작아 빠르다
* 사용 예시 : 실시간 스트리밍, VoIP, 온라인 게임, DNS, DHCP

<br/>

### 🌐 HTTP (HyperText Transfer Protocol)

---

* **HTTP**는 웹에서 서버·클라이언트가 데이터를 주고받기 위한 **규약**이다
* 구성 요소로는 대표적으로 Header, Body, Method, Status code 가 있다.

<!-- HTTP 요청·응답 흐름 그림 -->

![HTTP Request-Response Sequence](../applicationLayer/img/http.png)

#### 📦 동작 과정

1. 클라이언트가 요청을 보낸다
2. 서버가 처리 후 응답을 반환한다
3. 응답에는 *상태 코드*와 *콘텐츠*가 포함된다

#### 🧰 특징

* **Stateless** : 서버는 각 요청을 독립적으로 처리한다

<br/>

#### 🔨 HTTP 메서드

| 메서드         | 목적                 |
| ----------- | ------------------ |
| **GET**     | 리소스를 조회한다          |
| **POST**    | 리소스를 생성·처리한다       |
| **PUT**     | 리소스를 전체 교체한다       |
| **PATCH**   | 리소스를 부분 수정한다       |
| **DELETE**  | 리소스를 삭제한다          |
| **HEAD**    | 본문 없이 헤더만 조회한다     |
| **OPTIONS** | 서버가 지원하는 메서드를 조회한다 |

<br/>

#### 🏷️ HTTP 상태 코드

| 범주      | 의미       | 대표 코드                                                               |
| ------- | -------- | ------------------------------------------------------------------- |
| **1xx** | 정보 전달    | 100 Continue                                                        |
| **2xx** | 성공       | 200 OK, 201 Created, 204 No Content                                 |
| **3xx** | 리다이렉트    | 301 Moved Permanently, 302 Found, 304 Not Modified                  |
| **4xx** | 클라이언트 오류 | 400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found     |
| **5xx** | 서버 오류    | 500 Internal Server Error, 502 Bad Gateway, 503 Service Unavailable |

<br/>

### 🍪 Cookie

---

* **Cookie**는 Stateless 특성을 보완하기 위해 서버가 **사용자 상태 정보를 담아** 클라이언트에 발급하는 데이터다
* 동작

  1. 서버 → `Set-Cookie` 헤더로 쿠키를 보낸다
  2. 클라이언트가 쿠키를 저장한다
  3. 이후 요청마다 쿠키를 포함해 서버로 전송한다 → 서버는 사용자 식별 및 세션 관리에 활용한다

<br/>

### 🛡️ Proxy

---

* **Proxy 서버**는 서버·클라이언트 사이 **캐시 서버** 역할을 한다
* 동작

  1. 클라이언트 요청 → Proxy가 캐시에 데이터가 있는지 확인한다
  2. 캐시에 있으면 즉시 응답하고, 없으면 원 서버로 요청을 전달한다
* 장점

  * 응답 지연을 줄이고 서버 부하를 낮춘다
* 단점

  * **데이터 일관성 문제**가 발생할 수 있다 → `Conditional GET`으로 최신 여부를 확인한다

<br/>

### 📞 DNS (Domain Name System)

---

* **DNS**는 도메인 이름과 IP 주소를 매핑하는 **분산 디렉터리 서비스**이다

<!-- DNS 트리 구조 그림 -->

![DNS Hierarchy](../applicationLayer/img/DNS-tree.png)

#### 🔍 질의 흐름 예시 (`www.google.com`)

1. 클라이언트 → 로컬 DNS 서버로 질의를 보낸다
2. 로컬 DNS → 루트 DNS → TLD DNS → 권한 DNS 순으로 IP 주소를 찾는다
3. 최종 IP 주소가 클라이언트에 반환된다 (어플리케이션 계층에서 수행한다)

#### 🗂️ DNS 네임서버 계층

| 계층          | 역할                                       |
| ----------- | ---------------------------------------- |
| **루트 DNS**  | TLD 서버 위치를 알려준다                          |
| **TLD DNS** | `.com`, `.kr` 등 TLD별 **권한 DNS** 위치를 알려준다 |
| **권한 DNS**  | 도메인의 **최종 IP 주소**를 알려준다                  |
| **로컬 DNS**  | 사용자·기관 내부 첫 질의 지점이며 **캐시·프록시** 역할을 한다    |

* **특징**

  * 전 세계적으로 **분산·계층화**된 구조로 동작한다
  * 하나의 도메인에 **다수 IP**를 등록해 부하를 분산할 수 있다

<br/>

### 🧩 기타 용어

---

* **프로토콜**

  * 네트워크에서 패킷 형식과 절차를 정의한 **언어**이다
  * 송·수신자가 동일한 프로토콜을 이해해야 통신이 가능하다
  * 목적·특징에 따라 포함해야 할 **헤더 구조가 서로 다르다**

## 전송계층(Transport Layer)

> 프로토콜을 이해하려면 **헤더 필드**를 먼저 본다.
> 헤더는 “필요 최소·최대 크기” 안에서 **표현 범위**를 갖도록 설계한다.

---

### 전송계층의 역할

---

* **응용계층**과 **네트워크계층** 사이에서 동작한다.
* **End-to-End 통신**을 제공하며 **신뢰성·순서·오류 제어**를 담당한다.

### 다중화(Multiplexing) · 역다중화(Demultiplexing)

---

| 구분                 | 설명                                                                                         |
| ------------------ | ------------------------------------------------------------------------------------------ |
| **Multiplexing**   | 여러 애플리케이션(프로세스)에서 나온 데이터를 **하나의 네트워크 연결**로 합친다.<br>전송계층은 **포트 번호**를 부여해 *세그먼트*를 만든 후 전송한다. |
| **Demultiplexing** | 수신 세그먼트의 **포트 번호**를 확인해 **해당 애플리케이션**으로 정확히 전달한다.                                          |

### UDP (User Datagram Protocol)

---

| 필드                                 | 기능            |
| ---------------------------------- | ------------- |
| **Source Port / Destination Port** | 송신·수신 포트 번호   |
| **Length**                         | 헤더 + 데이터 총 길이 |
| **Checksum**                       | 오류 검출         |

* **비연결·비신뢰성** 특성으로 헤더가 **간단**하다.

### RDT(신뢰성 전송) 프로토콜 발전

---

| 버전          | 핵심 아이디어                            |
| ----------- | ---------------------------------- |
| **rdt 1.0** | 채널이 **완전 신뢰**라고 가정한다.              |
| **rdt 2.0** | 수신 측 **ACK/NAK 피드백**으로 오류를 수정한다.   |
| **rdt 2.1** | 피드백에도 오류 가능 → **시퀀스 번호**를 추가한다.    |
| **rdt 2.2** | NAK 제거, ACK + 시퀀스 번호만 사용한다.        |
| **rdt 3.0** | **타이머** 도입, 패킷·피드백 **유실** 시 재전송한다. |

### TCP (Transmission Control Protocol)

---

#### TCP 특성

* **점대점(Point-to-Point)**
* **신뢰성(Reliable)**
* **파이프라인(Pipelined)**
* **전이중(Full-Duplex)**
* **연결지향(Connection-Oriented)**
* **흐름제어(Flow-Controlled)**

#### 세그먼트 구조

![TCP Segment](../transportLayer/img/tcp_segment.png)

| 필드                            | 설명                     |
| ----------------------------- | ---------------------- |
| **Source / Destination Port** | 송·수신 포트                |
| **Sequence Number**           | 바이트 단위 시퀀스 시작 번호       |
| **Acknowledgment Number**     | 다음에 기대하는 바이트 번호        |
| **Flags(SYN, ACK, FIN …)**    | 제어 비트                  |
| **Receive Window**            | 수신 버퍼 여유(Flow Control) |
| **Checksum**                  | 오류 검출                  |
| **Options**                   | MSS, 윈도우 스케일 등         |

#### 버퍼 & 윈도우

* **Send Buffer** : 재전송·순서 관리를 위해 보관
* **Receive Buffer** : 도착 세그먼트를 순서대로 적재
* **전송 윈도우** = `min(Receive Window, Congestion Window)`

#### 흐름제어 (Flow Control)

* 수신 측은 **Receive Window** 값을 헤더에 담아 송신 측에 알린다.
* 송신 측이 데이터가 없을 때도 **1 Byte Probe** 를 보내 창 크기를 확인한다.

#### Nagle 알고리즘

* **작은 세그먼트** 남발을 막기 위해 **RTT 동안** 모은 데이터가 MSS 이상이면 한꺼번에 전송, 미만이면 지연 전송한다.

#### 연결 설정 — 3-Way Handshake

1. **SYN** : 클라이언트 → 서버 (`seq = x`)
2. **SYN + ACK** : 서버 → 클라이언트 (`seq = y`, `ack = x+1`)
3. **ACK** : 클라이언트 → 서버 (`ack = y+1`)

> 1·2 단계는 헤더만, 3 단계부터 **데이터 전송**이 가능하다.

#### 혼잡제어 (Congestion Control)

* **Congestion Window(cwnd)** 단위 = **MSS**
* 전송 윈도우 = `min(rwnd, cwnd)`
* 네트워크 혼잡 시 패킷 손실(타임아웃, 중복 ACK)로 **cwnd를 줄이고**
  정상 시 **점진적으로 늘린다** (“Additive-Increase, Multiplicative-Decrease”).
  ![congestion\_control](img/congestion_control.jpg)

### 핵심 용어 정리

---

| 용어                | 의미                                   |
| ----------------- | ------------------------------------ |
| **세그먼트(Segment)** | 전송계층 데이터 단위(TCP/UDP)                 |
| **포트(Port)**      | 프로세스 식별 번호(0–65 535)                 |
| **MSS**           | Maximum Segment Size, 세그먼트 데이터 최대 길이 |
| **RTT**           | Round-Trip Time, 왕복 지연               |
| **ACK / NAK**     | 긍정 / 부정 확인 응답                        |

## 네트워크 계층

---

### 📝 네트워크 계층 개요

---

* **역할**: 송신 호스트 → 수신 호스트로 **패킷(데이터그램)** 전달
* **서비스 모델**: 인터넷은 **최선형(best-effort)**
  → 전달/순서/지연/대역폭 **보장 없음**

### 🔀 데이터 평면 vs 제어 평면

---

* **데이터 평면(포워딩)**: 들어온 패킷을 **어느 출력 포트로 보낼지 즉시 결정**
* **Longest Prefix Matching**: 가장 긴 범위의 prefix가 매칭되는 주소로 결정
* **제어 평면(라우팅)**: 네트워크 전반의 **경로 계산** 및 **포워딩 테이블 설정**

  * 라우팅 알고리즘 → 포워딩 테이블 작성
  * 포워딩 테이블 → 패킷이 들어왔을 때 다음 링크 결정
* **SDN 관점**: 중앙 **컨트롤러**가 경로/정책 계산·배포, 장비는 **포워딩 전담**

![라우팅과 포워딩](../networkLayer/img/routing_and_forwarding.png)

### 🧱 라우터 내부 구조

---

* **입력 포트**: L1/L2 처리 → **포워딩 테이블 조회(최장 프리픽스 일치)** → 스위치 구조로 전달
* **스위치 구조(Fabric)**: 입력 ↔ 출력 연결(메모리/버스/크로스바 등 구현)
* **출력 포트**: 큐잉·스케줄링 후 링크로 송신
* **라우팅 프로세서**: 라우팅 프로토콜 실행 및 테이블 관리

### 🌐 IP 주소와 주요 기능 (IPv4 / IPv6 공통)

---

#### 주소 지정(Addressing)

* **IPv4 헤더**: 버전, 길이, TTL, 상위 프로토콜(TCP/UDP), 출발지/목적지 주소 포함
* **주소 단위**: 장비가 아닌 **인터페이스 단위**에 IP 부여
* **Classful Addressing**: 클래스 단위로 네트워크를 구분
* **CIDR**: `a.b.c.d/x` 형태, **프리픽스 기반 주소 요약**
* **DHCP**: IP 주소를 동적으로 임대하는 프로토콜
* **브로드캐스트**

  * 제한적: `255.255.255.255` (로컬 네트워크 전용)
  * 지정: 네트워크ID + all 1 (예: `192.168.1.255`)

![IP 헤더](../networkLayer/img/ip_header.png)

#### 단편화(Fragmentation)

* 네트워크 경로의 \*\*MTU(Maximum Transmission Unit)\*\*보다 큰 패킷을 작은 조각으로 나눔
* 송신측·라우터에서 단편화, 수신측에서 재조립

### 🧱 CIDR (Classless Inter-Domain Routing)

---

#### 개요

* **등장 배경**: 고정 클래스(A/B/C) 주소 체계는 **주소 낭비와 확장성 한계** 존재
* **CIDR**: 네트워크 경계를 \*\*가변 길이 프리픽스(/x)\*\*로 표현

  * 필요한 만큼 주소 할당 (낭비 최소화)
  * 여러 네트워크를 묶어 **경로 요약(Route Aggregation)**
* **효과**: IPv4 주소 고갈 완화, 네트워크 설계 유연성 증가, 라우팅 테이블 축소

#### 표기법

* `a.b.c.d/x` (예: `192.168.10.0/26`)
* `x` = 네트워크 비트 수, 나머지 `(32−x)` = 호스트 비트 수
* 같은 네트워크 판별: `IP & 마스크` 결과 동일 시 같은 네트워크
* 예: `/26` → 서브넷 마스크 `255.255.255.192`, 블록 크기 = 64

#### 호스트 계산법

* 공식: `2^(32−x) − 2` (네트워크 주소와 브로드캐스트 주소 제외)
* 예시:

  * `/24` → 254개 호스트
  * `/26` → 62개 호스트
  * `/30` → 2개 호스트 (P2P)

### 📡 DHCP (Dynamic Host Configuration Protocol)

---

#### 개요

* 클라이언트가 네트워크 접속 시 **자동으로 IP 및 관련 정보**(서브넷 마스크, 게이트웨이, DNS 등) 할당
* **임대(Lease)** 방식으로 주소 관리
* **포트 번호**: 서버(67), 클라이언트(68)

![DHCP 동작](../networkLayer/img/DHCP.png)

#### 동작 과정 (DORA)

1. **Discover**: 클라이언트 → 브로드캐스트(`255.255.255.255:67`) → “IP 주소 줄 서버 있나요?”
2. **Offer**: 서버 → 브로드캐스트(`255.255.255.255:68`), transaction ID 포함 → “이 IP 사용 가능”
3. **Request**: 클라이언트 → 브로드캐스트(`255.255.255.255:67`) → “저 이 주소 쓰겠습니다”
4. **ACK**: 서버 → 브로드캐스트(`255.255.255.255:68`) → “확인 완료, 사용하세요”

### 🔁 NAT (Network Address Translation)

---

![NAT 구조](../networkLayer/img/nat.png)

* 내부 **사설 IP ↔ 공인 IP:포트** 매핑으로 다수 호스트가 하나의 공인 IP 사용
* **Outbound**: 출발지 IP 재작성
* **Inbound**: 목적지 IP 재작성
* **장점**: 주소 절약, 내부 구조 은닉
* **제약**: 인바운드 연결·서버 운영 시 추가 설정 필요 (NAT Traversal/포트포워딩)

### 🆚 IPv4 vs IPv6

---

| 항목    | IPv4      | IPv6                    |
| ----- | --------- | ----------------------- |
| 주소 길이 | 32비트      | 128비트                   |
| 헤더    | 가변(옵션 포함) | 고정 40B + 확장 헤더          |
| 단편화   | 라우터/끝점    | 끝점만 (라우터는 과대 패킷 폐기 알림)  |
| 체크섬   | 있음        | 없음 (상·하위 계층 검증 의존)      |
| 주소 유형 | 유니/멀티캐스트  | 유니/멀티 + 애니캐스트           |
| 전환 방식 | —         | 듀얼스택, 터널링(IPv6-in-IPv4) |

### ⏳ 큐잉 & 스케줄링

---

* **입력 큐**: 스위치가 바쁘면 대기, **HOL(Head-of-Line) 차단** 가능
* **출력 큐**: 다수 입력이 한 출력으로 몰리면 대기/드롭 발생
* **스케줄링 방식**: FIFO, 우선순위 큐, 라운드로빈, WFQ
* **버퍼블로트**: 버퍼 과대 → 손실 줄지만 지연 증가

### 🛰️ 라우팅 알고리즘

---

* **Link State(LS)**: 링크 상태(비용)를 플러딩하여 전역 토폴로지 공유 → SPF(Dijkstra)로 최단 경로 계산
* **Distance Vector(DV)**: 이웃과 거리 벡터 교환 → 단순하지만 느린 수렴/루프 발생 가능
* **Hierarchical Routing**: 대규모 네트워크 확장을 위해 AS 단위 계층화, 경로 요약으로 테이블 축소

### 🌍 인터넷 라우팅 프로토콜

---

#### IGP (Interior Gateway Protocol)

* **RIP**: DV 기반, 홉 수 기준, 단순하나 대규모·수렴 속도 한계
* **OSPF**: LS 기반, 링크 비용 계산, Area 구조/빠른 수렴/풍부한 기능

#### EGP (Exterior Gateway Protocol)

* **BGP**: Path-Vector 기반, AS 간 정책 라우팅 표준, 다양한 경로 속성으로 최선 경로 선택

### 🧠 SDN · OpenFlow

---

* **매치 → 액션 모델**: 헤더/포트 기반 매칭 후 포워딩·드롭·복제·헤더수정 등의 액션 수행
* **중앙 컨트롤러**: 플로우 규칙을 배포해 네트워크 동작을 일관되게 변경·관리

### 🧳 미들박스 (중간 장비 기능)

---

* 예: NAT, 방화벽, IDS/IPS, 로드밸런서, 프록시, 캐시, WAN 가속
* **장점**: 보안·성능·운영 편의성 제공
* **고려사항**: 계층 경계를 넘는 검사·변조 가능

## 링크 계층

---

### 링크계층 개요

---

*  **주소화**: MAC 주소로 같은 네트워크 안의 주소를 구분한다.  
*  **스위치**: MAC 주소를 학습, 관리하는 역할을 한다.  
*  **Multiple Access Control**: 공유 매체에서 누가 언제 프레임을 보낼지 결정  
  * 대표적으로 CSMA/CD, CSMA/CA 가 있다.  
*  **프레이밍**: 링크계층은 IP 패킷을 프레임 단위로 캡슐화한다.  
*  **오류검출**: 프레임 전송 시 오류 여부를 확인하는 기능  

---

### 주소화

---

#### 주소화 개요
* 링크계층은 같은 네트워크 안에서 데이터를 주고받는 역할을 한다.  
* 이때 장치들을 식별하기 위해 MAC 주소를 사용한다.  

#### MAC 주소의 구조
* 크기: 48비트(6바이트)  
* 표기법: `AA:BB:CC:DD:EE:FF` (16진수 6쌍)  

#### MAC 주소 종류
* **Unicast 주소**: 특정 1대 장치에게 전송  
* **Broadcast 주소**: 모든 장치에게 전송 (`FF:FF:FF:FF:FF:FF`)  
* **Multicast 주소**: 특정 그룹에만 전송 (IPv4의 경우 `01:00:5E` 로 시작)  

#### MAC 주소 vs IP 주소, 그리고 ARP
* **MAC 주소**  
  * 링크계층에서 사용하는 하드웨어 주소  
  * 네트워크 카드(NIC)에 부여  
  * 같은 네트워크 안에서만 유효하다  

* **IP 주소**  
  * 네트워크 계층에서 사용하는 논리 주소  
  * 네트워크 부분 + 호스트 부분으로 구성  
  * 인터넷 전체 범위에서 종단 간(End-to-End) 통신을 위해 사용  

* **ARP (Address Resolution Protocol)**  
  * 상대방의 IP 주소 → MAC 주소로 변환하는 프로토콜  
  * 동작 방식  
    1. 송신자가 브로드캐스트로 “이 IP 가진 장치 누구세요?” 요청  
    2. 대상 장치가 자신의 MAC 주소를 유니캐스트로 응답  
    3. 결과를 ARP 캐시에 저장해 이후 재사용  

---

### 스위치의 MAC 주소 관리

1. **학습 (Learning)**  
   * 스위치가 프레임이 들어온 포트번호와 출발지 MAC 주소를 테이블에 기록  

2. **포워딩/필터링 (Forwarding/Filtering)**  
   * 수신한 프레임의 목적지 MAC을 테이블에서 확인  
     * 목적지 MAC 있음 → 해당 포트로만 전송  
     * 목적지 MAC 모름 → 모든 포트로 브로드캐스트처럼 전송  

---

### MAC 프로토콜

---

#### MAC 프로토콜 개요
* **MAC (Medium Access Control) 프로토콜**은  
  여러 장치가 **하나의 전송 매체(Medium)** 를 공유할 때 **누가 언제 전송할지 결정하는 규칙**.  
* 필요 이유: 충돌(Collision) 방지 및 효율적인 매체 사용  

---

#### CSMA (Carrier Sense Multiple Access)
* **Carrier Sense**: 보내기 전에 매체가 사용 중인지 확인  
  * NIC가 전송 매체를 계속 감시한다.
    * **유선**: 케이블의 전압·신호 레벨을 확인  
    * **무선**: 전파 세기를 확인  
* **Multiple Access**: 여러 장치가 매체를 공동 사용  
* **원리**: **“듣고, 비면 전송한다”**


---

#### CSMA/CD (Collision Detection, 유선 Ethernet)
1. 매체를 듣는다 → 비면 송신  
2. 동시에 송신 시 충돌 발생  
3. 충돌 감지 → 즉시 전송 중단  
4. **랜덤 대기(backoff)** 후 재전송  

“부딪히면 멈추고, 기다렸다가 다시 보내라”  

---

#### CSMA/CA (Collision Avoidance, 무선 LAN)
1. 매체를 듣는다 → 비면 바로 송신하지 않고 대기  
2. **랜덤 백오프 후 송신**  
3. 수신 측이 **ACK 프레임**을 보내면 성공 확인 (CSMA/CA 에서는 무선이라서 신호 변화로 하기 힘들다!)
4. 필요 시 **RTS/CTS**(예약)으로 숨은 단말 문제 해결  

“부딪히기 전에 조심스럽게 보내고, ACK로 확인한다”  
