# Process

---

메모리에 다수의 프로그램들이 적재되어 병행 실행되는 것이 허용되는 오늘 날의 컴퓨터 <br> 
=> 이 때문에 다양한 프로그램을 보다 견고하게 제어하고 보다 구획화가 필요

**프로세스**의 등장 배경 => 실행 중인 프로그램. 시분할 시스템에서의 작업의 단위

> 실행 중인 프로그램이고 모든 계산의 기초가 되는 프로세스의 개념<br>
> 스케줄링, 생성 및 종료 등을 포함한 프로세스의 다양한 특성을 소개<br>
> 공유 메모리와 메시지 전달 기법을 사용한 프로세스 간 통신에 대해 탐구.<br>
> 클라이언트 - 서버 시스템에서의 통신에 대해 기술

## 프로세스 개념

---

### 프로세스
![process structure](./img/process-structure.png)
- 실행 중인 프로그램.
  - 프로그램 카운터의 값과 처리기 레지스터의 내용으로 대표되는 현재 활동을 포함.
  - 실행 파일이 메모리에 load될 때 프로그램은 프로세스가 됨.
- 프로세스는 임시적인 자료를 가지는 프로세스 **스택**(함수 매개변수, 복귀 주소, 로컬변수 등)<br>전역변수를 저장하는 **데이터**<br> 프로세스 실행 중에 동적으로 할당되는 **힙**<br>코드가 저장되어 있는 **text**
- 두 프로세스들은 동일한 프로그램에 연관이 가능하지만 별도의 실행순서로 간주
  - 또 비슷하게 프로세스가 실행되는 과정에서 다른 프로세스를 생성하는 것이 보통.

### 프로세스 상태
![process state](./img/process-state.png)
프로세스는 실행되면서 그 상태가 변한다. 그 상태는 현재의 활동에 따라서 정의된다.

- **new**
  - 프로세스가 생성 중인 상태
- **running**
  - 명령어가 실행되고 있는 상태
- **waiting**
  - 프로세스가 어떤 일이 일어나기를 기다리고 있는 상태
- **ready**
  - 프로세스가 처리기에 할당되기를 기다리는 상태
- **terminated**
  - 프로세스의 실행이 종료된 상태.

어느 한 순간에 한 처리기 상에는 오직 하나의 프로세스만이 실행될 수 있으므로 많은 프로세스는 준비완료 및 대기 상태에 있다.

### Process Control Block, PCB
![PCB](./img/proces-control-block.png)
프로세스 제어 블록은 특정 프로세스와 연관된 여러 정보를 기록한다.
- **process state**
  - ```new, ready, running, wating, halted``` 상태
- **Program Counter(PC)**
  - 다음에 실행할 명령어의 주소
- **CPU registers**
  - 컴퓨터의 구조에 따라 다양한 수와 타입을 가짐
  - accumulator, index register, stack register, general-purpose register, condition code 정보가 포함
  - 프로그램 카운터와 함께 이 상태 정보는 나중에 프로세스가 올바르게 실행되도록 하기 위해 인터럽트 발생시 저장되어야 한다.
- **CPU Scheduling information**
  - 프로세스의 우선순위, 스케줄링 큐에 대한 포인터와 다른 스케줄링 매개변수들을 포함
- **메모리 관리 정보**
  - OS에 의해 사용되는 메모리 시스템에 따라 base register와 limit register 값과 페이지 테이블, 세그먼트 테이브로가 같은 정보를 저장
- **accounting 정보**
  - CPU 사용시간과 경과된 실시간, 시간제한, 계정번호, job or process 번호를 포함
- **입출력 상태 정보**
  - 프로세스에게 할당된 입출력 장치들과 열린 파일의 목록을 포함

### Threads
- 현대의 운영체제는 프로세스 개념을 확장하여 하나의 프로세스가 다수의 실행 스레드를 가질 수 있게 허용
- 따라서 프로세스가 한번에 하나 이상의 일을 수행할 수 있도록 허영 => 스레드가 병렬로 실행 가능.
- PCB 내부에 Thread에 대한 정보도 저장되어 있어야 함.

## Process Scheduling

---
- **다중 프로그래밍의 목적**
  - CPU 이용을 최대화하기 위함.
- **시분할 프로그래밍의 목적**
  - 각 프로그램이 실행되는 동안 사용자가 상호작용 할 수 있도록 프로세스들 사이에서 CPU를 교체하는 것

이 목적을 달성하기 위해 **프로세스 스케줄러**는 CPU에서 실행가능한 여러 프로세스들 중에서 하나의 프로세스 선택<br>
만일 프로세스가 여러개 있고 하나의 프로세스가 실행 중이면 다른 프로세스는 대기

### Scheduling Queue
- 프로세스가 시스템에 들어오면 이들은 job queue에 들어가고 이 큐는 시스템 안의 모든 프로세스로 구성된다.
- 메인 메모리에 존재하며 준비완료 상태에서 실행을 대기하는 프로세스들은 ```ready queue``` 리스트 상에 유지된다.
  - 이 큐는 일반적으로 **연결 리스트**로 이루어져 있으며 헤더는 리스트의 첫번째와 마지막 PCB를 가지는 포인터를 포함.
  - 각 PCB는 준비 완료 큐에 있는 **다음 프로세스를 가리키는 포인터 필드**를 가짐
- 시스템에는 여러 큐가 존재하는데 특정 입출력 장치를 대기하는 프로세스들의 리스트를 wait(device) queue라고 함.
  - 각 device queue를 가진다.
- 프로세스 스케줄링의 공통적인 표현 방법은 queueing diagram
![queueing diagram](./img/queueing-diagram.png)
- 각 사각형은 하나의 큐를 나타내며 두가지 타입의 큐가 존재.
  - ```원```은 **큐를 서비스하는 자원**이고 ```화살표```는 **프로세스의 from을 표현**한다.
- 새로운 프로세스는 처음에 준비완료 큐에 놓인다.
- 프로세스는 실행을 위하여 선택될 때 CPU를 할당받을 때까지 준비 완료 큐에서 대기한다.
- 일단 프로세스에 CPU가 할당되어 실행되면 여러가지 사건들 중에 하나가 발생
  1. 프로세스가 입출력 요청을 하여 입출력 큐에 넣어질 수가 있다.
  2. 프로세스가 새로운 자식 프로세스를 생성하고 자식 프로세스의 종료를 기다릴 수 있다.
  3. 프로세스가 인터럽트의 결과에 의해 강제로 CPU로 부터 제거되고, 준비 완료 큐에 다시 놓일 수 있다.
처음 두 경우는 프로세스는 wait에서 ready 상태로 전환되고 ready queue에 넣어지게 되고<br> 
이 과정은 프로세스가 종료될 때까지 반복되며 종료되면 모든 큐에서 삭제되고 그 자신의 PCB와 자원을 반납한다.

### Scheduler
프로세스는 다양한 스케줄링 큐들 사이에서 이동한다. <br>
운영체제는 알고리즘에 따라 하나의 프로세스를 선택하게 되고 이것은 **스케줄러**에 의해 결정된다.

- ```장기 스케줄러(job scheduler)```는 이 풀에서 프로세스들을 선택하여 실행하기 위해 메모리로 load한다.
  - 실행 빈도수가 적음
  - 메모리에 있는 프로세스들의 수를 제어
  - 이 프로세스의 수가 안정적이면 프로세스의 생성률과 이탈률이 같아야한다.
  - 장기 스케줄러는 프로세스가 시스템을 떠날 때만 호출될 필요가 있다
- ```단기 스케줄러(CPU 스케줄러)```는 실행 준비가 완료되어 있는 프로세스들 중에서 선택하여 이들 중 하나에게 CPU를 할당한다.
  - CPU를 선점하기 위해 자주 새로운 프로세스를 선택해야 함.
  - 프로세스는 입출력 요청을 위해 대기 전까지 실행될 수 있다.
  - 매우 빨라야 한다.(프로세스 교체에 CPU를 낭비 폭을 낮추기 위해)
> 현대 시대의 OS는 가상메모리를 통해 장기 스케줄러를 잘 사용하지 않는다고 한다.

### Context Switch
![context switch](./img/context-switch.png)
> 인터럽트를 통해 OS가 CPU를 현재 작업에서 빼앗아 커널 루틴을 실행할 수 있게 한다.<br>
> 인터럽트가 발생하면 시스템은 인터럽트 처리가 끝난 후에 Context를 복구할 수 있도록 현재 실행중인 프로세스의 현재 Context를 저장할 필요가 있고<br>
> 이는 프로세스를 중단했다가 재개하는 작업

- **Context**
  - 프로세스의 PCB에 표현된 정보
  - CPU 레지스터의 값, 프로세스 상태, 메모리 관리 정보 등
- OS가 커널모드이건, 사용자모드이건 CPU 상태를 저장하는 작업을 수행하고 연산을 재개하기 위해서 수행한다.
- CPU를 다른 프로세스로 전환하려면 이전 프로세스의 상태를 보관하고 새로운 프로세스의 보관된 상태를 복구하는 작업이 필요<br> => **Context Switch**
- 커널은 과거 프로세스의 문맥을 PCB에 저장하고, 스케줄 된 새로운 프로세스의 저장된 문맥을 복구한다. 
  - 이것이 진행될 동안 시스템은 아무런 유용한 일을 못하기 때문에 Context Switch는 오버헤드가 큰 작업.
  - Context Switch 시간은 하드웨어 자원에 따라 좌우되며 메모리 관리 기법에 따라 크게 달라진다.

## 프로세스에 대한 연산

---
대부분의 시스템 내의 프로세스들은 병행 실행될 수 있으며, 동적으로 생성되고 제거되어야한다.<br>
운영체제는 이를 위한 프로세스 생성 및 종료를 위한 기법을 제공해야 함.

### Process Creation
![process tree](./img/process-tree.png)
실행되는 동안의 프로세스느 다른 프로세스를 생성할 수 있는데 생성하는 프로세스를 **부모 프로세스**, 생성된 프로세스를 **자식 프로세스**라 함.

대부분의 현대 OS는 유일한 **프로세스 식별자(PID)**를 사용하여 프로세스를 구분하는데 각 프로세스의 고유한 값이고, index처럼 사용이 가능하다.

(UNIX의 경우)
pid가 1인 것은 언제나 init 프로세스이고, 모든 프로세스의 부모 역할을 한다.
시스템이 부팅되면 init 프로세스가 여러 프로세스를 생성한다.

일반적으로 프로세스가 자식 프로세스를 생성할 때 자식 프로세스는 자신의 임무를 달성하기 위해 어떤 자원(CPU 시간, 메모리, 파일, 입출력 장치)가 필요.
자식 프로세스는 이 자원을 OS로부터 얻거나 부모 프로세스가 가진 자원의 일부를 사용할 수 있다.<br>
=> 이르 통해 시스템의 과부화 방지

**프로세스가 새로운 프로세스를 생성할 때 실행시키는 두가지 가능한 방법**
1. 부모와 자식을 병행하게 실행
2. 부모는 일부 또는 모든 자식이 실행을 종료할 때까지 기다림.

새로운 프로세스들의 주소 공간 측면에서 볼 때 두가지 가능성 존재.
1. 자식 프로세스는 부모 프로세스의 복사본
2. 자식 프로세스가 새로운 프로그램

![fork system call](./img/fork%20process.png)
- ```fork()```의 반환 값이 자식 프로세스는 **0**, 부모 프로세스는 **0이 아닌 값**(자식 프로세스의 PID)
- ```fork()``` system call 이후 ```exec()``` system call을 사용하며 ㄴ자신의 메모리 공간을 새로운 프로그램으로 교체.
- exec()는 오류가 발생하지 않는 한 제어를 바노한하지 않으며 부모는 자식이 종료될 때까지 ready queue에서 자신을 제거하기 위해 ```wait()``` system call을 사용

### Process Termination
프로세스가 마지막 문장의 실행을 끝내고 ```exit()``` system call을 사용하여 운영체제에게 자신의 삭제를 요청하면 종료한다.<br> 
프로세스는 자신의 부모 프로세스에게 **상태 값을 반환**한다. <br>
모든 자원들(메모리, 파일, 입출력 버퍼 등..) 운영체제에게 반환한다.

부모가 자식의 PID를 이용하여 프로세스를 종료시킬 수 있는데 다음과 같은 이유에 그 동작이 가능하다.
- 자식이 자신에게 할당된 자원을 초과하여 사용할 때
- 자식에게 할당된 task가 더이상 없을 때
- 부모가 exit하는데 자식이 아직 남아있을 때

프로세스의 종료 상태가 저장되는 프로세스 테이블의 해당 항목은 부모 프로세스가 ```wait()```을 호출할 때까지 남아있게 된다.<br>
종료 되었지만 부모 프로세스가 아직 ```wait()```을 호출하지 않는 프로세스를 **좀비 프로세스**라고 한다.<br>
종료하게 되면 모든 프로세스는 좀비 상태가 되지만 아주 짧은 시간동안만 머무르고 부모가 wait을 호출하면 좀비 프로세스의 프로세스 식별자와 프로세스 테이블의 해당 항목이 운영체제에게 반환된다.

부모 프로세스가 ```wait()```을 호출하는 대신 종료한다면 잦식 프로세스는 **고아 프로세스**가 된다.<br>
고아 프로세스는 init 프로세스를 부모 프로세스로 만들고 init 프로세스는 주기적으로 ```wait()```호출하여 고아 프로세스의 종료 상태를 수집하여 프로세스 식별자와 테이블 항목을 반환한다.


