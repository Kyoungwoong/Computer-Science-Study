# Multiple-Processor Scheduling

---

현대의 컴퓨터는 대부분 여러 개의 CPU 코어를 가진 멀티프로세서이다.  
CPU가 하나일 때도 자원 관리와 스케줄링이 어려웠지만, CPU가 여러 개인 경우 스케줄링은 더욱 복잡해진다.

## Homogeneous

- 공동 큐를 만들어 한 줄로 세운다.
- Queue에 한 줄로 세워서 각 프로세서가 알아서 꺼내 가게 할 수 있다.

## Load Sharing

- 일부 프로세서에 job이 몰리지 않도록 부하를 적절히 공유해야 한다.

### 별개의 큐 vs 공동 큐

- **공동 큐:**  
  여러 CPU가 공동으로 사용하는 큐를 배치한다.  
  부하분산은 쉽지만 다수의 CPU가 접근하기 때문에 병행제어(locking)를 사용해야 한다.

- **별개의 큐:**  
  각 CPU마다 큐를 배치한다.  
  이렇게 되면 특정 작업 큐에 job이 몰리고, 다른 큐는 비게 되는 문제가 발생할 수 있다.

## Symmetric Multiprocessing (SMP)

- 모든 CPU가 대등하게 OS 커널 코드를 실행할 수 있다.
- 각 프로세서가 각자 알아서 스케줄링 결정을 내린다.

## Asymmetric Multiprocessing (AMP)

- 하나의 프로세서가 시스템 데이터 접근과 공유를 책임지고, 나머지 프로세서는 그 결정에 따른다.

---

# Real-Time Scheduling

---

- **Hard Real-Time:**  
  Deadline 이내에 반드시 작업을 완료해야 한다.

- **Soft Real-Time:**  
  일반 프로세스보다 높은 우선순위를 가져야 한다.

- **비선점형 스케줄링과 Real-Time:**  
  비선점형 스케줄링에서도 Real-Time 우선순위를 부여할 수 있다.

---

# Thread Scheduling

---

스레드는 하나의 프로세스 내에서 여러 작업을 병행 처리할 필요성에서 등장했다.  
여러 스레드를 여러 CPU에 할당할 때 운영체제에 맡길지, 사용자 애플리케이션에 맡길지를 결정해야 한다.  
예를 들어 Tomcat은 운영체제에 Thread Scheduling을 전적으로 맡긴다.

## Local Scheduling

- User Level Thread의 경우, 사용자 수준의 Thread Library가 어떤 Thread를 스케줄할지 결정한다.
- CPU는 스레드의 존재를 알지 못하며, 사용자(애플리케이션)가 스레드에 자원을 할당한다.

## Global Scheduling

- Kernel Level Thread의 경우, 커널의 단기 스케줄러가 어떤 Thread를 스케줄할지 결정한다.
- 현대 OS는 대부분 Global Scheduling을 채택해 운영체제가 스레드 스케줄링을 담당한다.

---

# Algorithm Evaluation

---

CPU 스케줄링 알고리즘을 평가하는 방법은 다음과 같다.

## Queueing Models

- 이론적인 방법으로, 네트워크 성능 측정에도 사용된다.
- 도착률(arrival rate)과 서비스율(service rate)을 확률 분포로 두고 각종 성능 지표를 계산한다.
- CPU 처리량, 대기 시간 등을 측정할 수 있다.

## Implementation & Measurement

- 실제 시스템에 알고리즘을 구현하고, 실제 작업을 수행하며 성능 지표를 측정한다.
- 리눅스 커널 코드를 수정해야 하므로 매우 어렵다.

## Simulation

- 알고리즘을 모의 프로그램으로 작성하고, 실제와 유사한 trace 데이터를 입력해 결과를 비교한다.
- 각 알고리즘의 시뮬레이터를 만들어 비교한다.

---

# Race Condition

---

Race Condition은 **공유 데이터에 대한 동시 접근**으로 인해 일관성이 깨지는 문제이다.  
다음과 같은 경우 발생할 수 있다.

1. **커널 수행 중 인터럽트 발생 시:**  
   단일 CPU 환경에서도 커널 코드 실행 중 인터럽트가 발생하여 인터럽트 핸들러가 같은 커널 공유 데이터에 접근할 때.

2. **시스템 콜 중 문맥 교환 발생 시:**  
   커널 모드에서 시스템 콜을 수행 중일 때, 할당 시간 만료 등으로 문맥 교환이 발생하면 다른 프로세스가 동일 자원에 접근할 수 있다.

3. **멀티프로세서 환경:**  
   여러 CPU가 동시에 Shared Memory 내의 커널 데이터를 접근할 때.

---

# Process Synchronization

---

경쟁상태가 일어난 경우, 공유 데이터의 동시 접근으로 인한 불일치를 막기 위해 **동기화**가 필요하다.  
프로세스 간 실행 순서를 제어하는 메커니즘을 사용해야 한다.

## Critical Section

- 공유 자원에 접근하는 코드 영역이다.
- Critical Section 내의 동시 접근을 방지해야 한다.

---

## 동기화 문제 해결 조건

1. **Mutual Exclusion (상호배제):**  
   한 프로세스가 Critical Section을 실행 중이면 다른 프로세스는 진입할 수 없다.

2. **Progress (진행):**  
   아무도 Critical Section에 없을 때, 진입 가능한 프로세스가 있다면 막지 않아야 한다.

3. **Bounded Waiting (유한대기):**  
   특정 프로세스가 무한정 대기하지 않아야 한다 (Starvation 방지).

---

# 동기화 문제 해결 알고리즘

---

## Algorithm 1 (Turn 방식)

- 자신의 턴인지 확인 후 Critical Section 진입.
- 두 프로세스가 동시에 들어가지 않지만, 한쪽이 더 자주 진입해야 할 때 비효율적이다.

## Algorithm 2 (Flag 방식)

- 자신의 턴일 때 flag를 세우고 진입하는 방식이다.

## Peterson’s Algorithm

- 알고리즘 1과 2를 결합한 방식이다.
- 상호배제를 만족하지만, Spin Lock 형태로 CPU 자원을 낭비하는 단점이 있다.

---

# 하드웨어적 해결 방법

---

하드웨어적으로 원자성을 보장하는 명령을 통해 단순하게 해결할 수 있다.

절차:

1. 변수 `a`를 읽는다.
2. `a`를 1로 설정한다.

이 경우, `a`가 1일 때는 다른 프로세스가 Critical Section에 진입하지 못한다.

---

# Semaphores

---

Semaphore는 자원 접근을 추상화한 **정수형 추상 자료형**이다.

- **P 연산 (wait):** 자원을 획득, 락을 건다.
- **V 연산 (signal):** 자원을 반납, 락을 푼다.
- 두 연산은 **원자적(atomic)** 이어야 한다.

---

## Semaphore의 종류

- **Binary Semaphore:** 값이 0 또는 1, Mutual Exclusion 구현에 사용된다. (뮤텍스와 유사)
- **Counting Semaphore:** 값이 임의의 양의 정수, 여러 개의 동일 자원을 제어할 때 사용된다.

---

## Block / Wakeup 구현

Busy-wait 방식은 CPU를 점유한 채 대기하므로 비효율적이다.  
이를 해결하기 위해 대기 큐(wait queue)를 사용한다.

- `block()`: 프로세스를 wait queue에 넣는다.
- `wakeup()`: 프로세스를 ready queue로 이동시킨다.

---

## Busy-Wait vs Block/Wakeup

- Busy-wait: CPU를 낭비하며 반복문으로 대기.
- Block/Wakeup: 대기 중 프로세스를 sleep 상태로 두어 효율적이다.

---

# Deadlock and Starvation

---

**Deadlock:**  
둘 이상의 프로세스가 자원을 서로 기다리며 영원히 대기 상태에 빠지는 현상이다.  
자원을 반납하지 않으면 세마포어 큐에서 빠져나올 수 없다.

---

# Classical Problems of Synchronization

---

- **Bounded-Buffer Problem (Producer-Consumer):**  
  생산자와 소비자가 공유 버퍼를 사용할 때의 동기화 문제.

- **Readers-Writers Problem:**  
  여러 Reader가 동시에 접근 가능하지만, Writer는 단독 접근해야 하는 문제.

- **Monitor:**  
  동기화 문제를 고수준 언어 수준에서 추상화하여 해결.

# Deadlock (교착 상태)

---

## Deadlock이란?

운영체제에서 **데드락(Deadlock)** 또는 **교착 상태**란,  
시스템 자원에 대한 요구가 서로 얽혀 **무한 대기 상태**에 빠지는 현상을 말한다.

즉, **둘 이상의 프로세스가 서로가 점유한 자원을 기다리며 무한정 대기하는 상황**이다.  
이 경우 각 프로세스는 자원을 점유한 채로 다음 단계로 진행할 수 없게 된다.

---

## Deadlock 발생 조건

데드락이 발생하기 위한 **4가지 필수 조건**이 모두 충족되어야 한다.  
이 중 하나라도 제거되면 데드락은 발생하지 않는다.

1. **상호 배제 (Mutual Exclusion)**  
   한 번에 하나의 프로세스만 자원을 사용할 수 있다.  
   사용 중인 자원을 다른 프로세스가 사용하려면, 그 자원이 **해제될 때까지 기다려야 한다.**

2. **점유 대기 (Hold and Wait)**  
   프로세스가 최소 하나의 자원을 보유한 상태에서,  
   다른 자원을 요청하며 기다리는 상황이 존재해야 한다.

3. **비선점 (No Preemption)**  
   이미 할당된 자원을 **강제로 빼앗을 수 없다.**  
   프로세스가 스스로 자원을 반납할 때까지 기다려야 한다.

4. **순환 대기 (Circular Wait)**  
   자원을 기다리는 프로세스 간에 **사이클 형태의 대기 관계**가 존재해야 한다.  
   예: P1이 P2의 자원을 기다리고, P2는 P3의 자원을 기다리며, P3는 다시 P1의 자원을 기다리는 형태.

---

## Deadlock 해결 방법

데드락을 처리하는 대표적인 **네 가지 접근 방식**은 다음과 같다.

1. **예방 (Prevention)** — 애초에 데드락이 발생하지 않도록 한다.
2. **회피 (Avoidance)** — 데드락이 발생할 가능성을 피하도록 자원 할당을 제어한다.
3. **탐지 및 회복 (Detection & Recovery)** — 데드락을 허용하되, 탐지 후 복구한다.
4. **무시 (Ignorance)** — 데드락을 명시적으로 처리하지 않고 방치한다. (대부분의 운영체제에서 채택)

---

# Deadlock 예방 (Prevention)

---

데드락의 4가지 필요 조건 중 **하나 이상을 만족하지 않도록** 하여 교착 상태를 예방한다.

| 데드락 발생 조건 | 예방 방법                                                               | 부작용                               |
| ---------------- | ----------------------------------------------------------------------- | ------------------------------------ |
| 상호 배제        | 한 번에 여러 프로세스가 공유 자원을 사용할 수 있도록 한다.              | 데이터 불일치, 동기화 문제 발생 가능 |
| 점유 대기        | 프로세스 시작 시 필요한 모든 자원을 한꺼번에 요청하게 한다.             | 자원 활용률 저하, 대기 시간 증가     |
| 비선점           | 이미 할당된 자원을 높은 우선순위 프로세스가 강제로 선점할 수 있게 한다. | 프로세스 간 형평성 저하              |
| 순환 대기        | 자원을 요청할 수 있는 순서를 정해 일방향으로만 요청하게 한다.           | 자원 할당의 유연성 감소              |

이처럼 예방 기법은 단순하지만 **시스템 효율성을 낮추는 단점**이 있다.  
따라서 실무에서는 완전한 예방보다는 회피(avoidance) 기법을 사용하는 경우가 많다.

---

# Deadlock 회피 (Avoidance)

---

데드락이 발생하지 않도록 **자원 할당 전 시뮬레이션을 통해 안전 여부를 판단**한다.  
핵심 개념은 **안정 상태(Safe State)** 와 **안전 순서(Safe Sequence)** 이다.

- **안정 상태 (Safe State):**  
  시스템이 모든 프로세스에게 자원을 할당하더라도 교착 상태 없이 실행을 마칠 수 있는 상태.
- **안전 순서 (Safe Sequence):**  
  데드락이 발생하지 않도록 자원을 할당하고 실행할 수 있는 프로세스의 순서.

불안정 상태(Unsafe State)는 반드시 데드락이 발생하는 것은 아니지만,  
**데드락으로 발전할 가능성이 있는 상태**를 의미한다.

---

## 은행원 알고리즘 (Banker’s Algorithm)

데드락 회피 알고리즘의 대표적인 예로, 다익스트라(Dijkstra)가 제안했다.  
자원 할당 전에 **시스템이 여전히 Safe State를 유지할 수 있는지 검사**한다.

### 예시

시스템의 총 자원이 12개이고, 세 개의 프로세스(P0, P1, P2)가 있다고 가정한다.

| 프로세스 | Max | Allocation | Need | Available |
| -------- | --- | ---------- | ---- | --------- |
| P0       | 10  | 5          | 5    |           |
| P1       | 4   | 2          | 2    |           |
| P2       | 9   | 2          | 7    |           |

현재 사용 중인 자원의 합은 5 + 2 + 2 = 9개이므로  
남은 자원(Available)은 12 - 9 = **3개**이다.

### Safe Sequence 찾기

1. **P1**은 Need가 2이므로 Available(3개)로 실행 가능 → 실행 후 자원 4개 반납 → Available = 5
2. **P0**는 Need가 5이므로 실행 가능 → 실행 후 자원 10개 반납 → Available = 10
3. **P2**는 Need가 7이므로 실행 가능 → 실행 후 자원 9개 반납 → Available = 12

→ 따라서 **Safe Sequence = <P1, P0, P2>**  
이 경우 모든 프로세스가 교착 상태 없이 종료된다.

하지만 만약 P2가 처음에 자원을 하나 더 가지고 있었다면 (Allocation=3),  
Available은 2가 되어 **Safe Sequence를 만족할 수 없게 된다.**  
이 경우, 운영체제가 자원 할당을 거부함으로써 데드락을 피할 수 있다.

### 특징 및 단점

- 시스템의 최대 자원 요구량을 사전에 알아야 한다.
- 자원 수가 고정되어 있어야 한다.
- 계산량이 많고, 자원 이용률이 낮아질 수 있다.

---

# Deadlock 탐지 (Detection) 및 회복 (Recovery)

---

예방이나 회피 기법을 사용하지 않는 시스템에서는 데드락이 발생할 수 있다.  
이 경우 **탐지(Detection)** 와 **회복(Recovery)** 알고리즘을 통해 문제를 해결한다.

## 1. 탐지 (Detection)

- 현재의 **Allocation, Request, Available** 정보를 기반으로 시스템 상태를 점검한다.
- 은행원 알고리즘과 유사한 방식으로 교착 상태 여부를 판단한다.
- **자원 할당 그래프(Resource Allocation Graph)** 를 이용해  
  **사이클이 존재하는지** 확인함으로써 데드락을 탐지할 수도 있다.

## 2. 회복 (Recovery)

데드락이 탐지되면 다음과 같은 방법으로 복구할 수 있다.

### (1) 프로세스 종료

- 교착 상태에 빠진 모든 프로세스를 한꺼번에 중단시킨다.  
  → 부분 결과가 손실될 위험이 있다.
- 또는, 프로세스를 하나씩 중단시키며 데드락이 해소될 때까지 반복한다.  
  → 탐지 알고리즘을 매번 수행해야 하므로 오버헤드 발생.

### (2) 자원 선점

- 특정 프로세스에서 자원을 강제로 회수(선점)해  
  다른 프로세스에게 재할당한다.
- 선점 시 데이터 일관성 문제가 발생할 수 있으며,  
  재시작 시 복원 메커니즘이 필요하다.

---

# Deadlock 무시 (Ignorance)

---

현대 운영체제 대부분은 **데드락을 명시적으로 처리하지 않는다.**  
데드락 발생 빈도가 낮고, 처리 비용이 높기 때문이다.

즉, 데드락이 발생하더라도 **사용자나 시스템 관리자가 수동으로 해결**하도록 두는 방식을 사용한다.  
이 방식을 **Deadlock Ignorance** 또는 **방치(Do Nothing)** 방식이라고 한다.

> 대표적으로 UNIX, Linux, Windows 등 대부분의 운영체제가 이 방식을 채택한다.
