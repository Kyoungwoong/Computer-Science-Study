# 운영체제 스케줄링 파트  피드백
## Interview

- ### Q1) ContextSwitching이 뭔 설명해주세요

        A)  프로세스 A에서 B로 넘어 갈 때, 프로세스A에 대한 정보를 저장하고 B에 대한 정보를 복구를 해야되는데 그 과정에서 정보를 저장하고 불러오는 비용을 ContextSwitching 이라고 합니다.
    
    <br>

  - ### Q1-1) 그렇다면 ContextSwitching이 자주 일어나면 무슨 일이 일어날까요?

          A)  아무래도 프로세스에 대한 정보를 저장하고 불러오는데에 대한 그런 내용이 프로세스를 실행하는데 쓰는 비용이 아니기 때문에 추가적으로 시간이 든다고 말할 수 있을 것 같습니다.

  
    <br>

  - ### Q1-2) 프로세스를 저장하고 정보를 불러오는거에 대한 구체적인 동작원리를 말해주세요

          A)  프로세스A를 PCB블록에 저장하고, PCB안에서는 프로그램 카운터나 레지스터 값드을 저장하는 것으로 알고 있다. 복원 과정에서도 똑같은 정보들을 복원한다.

      <br>

### 정균 피드백
  > 프로스세A에 대한정보, 프로세스 B에 대한 정보를 언급을 해주셨는데 제 생각으로는 정보도 좋지만 프로세스의 **`상태`** 라고 말씀해주시는게 좋을 것 같아요!! 저도 대답을 잘 하지는 못했지만 답변하실 때 Context Switching 과정에서 Context에는 프로세스 카운터, 레지스터 값, 스택 포인터, 메모리 관리 정보 등이 포함된다. 이런 식으로 추가를 해도 정말 좋을 것 같습니다!!<br><br>그리고 오버헤드가 발생하는것도 아시니깐 Context Switching 과정에서 저장, 복원 과정에서 CPU 자원이 소비되는 오버헤드가 있다 라고 미리 언급을 하셨으면 더 좋은 점수를 받고 1-1 같은 추가 질문을 안받을 수도 있었을 것 같아요!!

---

- ### Q2) 프로세스랑 스레드에 대해서 질문을 드릴건데, 멀티스레드 환경이 항상 성능향상으로 이어지진 않는데 항상 성능향상이 보장되지 않는 이유에 대해서 뭐라고 생각하세요

        A)  멀티스레드를 실행을 해도 성능 향상이 안되는 상황은 I/O bound 작업이 아닐 때, 그럴 때 성능 향상이 일어나지 않는다고 생각합니다. 왜냐면 멀티스레드로 프로그램을 실행을 하게 되면은 그렇게 된다 하더라도 CPU는 한번에 하나의 기계어만 해석을 하고 실행을 하기 때문에 I.O 바운드가 아니라 CPU바운드한 작업이라면 어쨌든 하나의 CPU가 실행을 하기 때문에 이점이 없습니다.

    <br>

### 정균 피드백
  > 멀티스레드의 한계에는 병렬성의 한계와 오버헤드 문제가 있고 이걸 정리하면 크게 세가지 정도가 있습니다.<br>첫번째로는 CPU 코어 수의 한계가 있습니다. CPU-bound 작업에서는 코어 수보다 많은 스레드를 Context Switching 비용만 늘어납니다.<br> 두번째로는 공유 자원 접근 시 동기화 비용이 발생합니다. 스레드 간에 lock이나 뮤텍스를 사용하면 병렬성이 떨어지고 대기 시간이 길어질 수 있습니다. 세번째로는, I/O-bound 작업이 아닌 경우에는 멀티스레드로 나눠도 실제 병렬 실행 효과가 거의 없을 수 있습니다.<br>이 부분도 알아주시면 좋을 것 같아요!!

---

- ### Q3) 데드락과 교착상태에 대해서 알고 계신가요?

        A) 잘 모르겠습니다.

#### 정균
  > 사실 요 문항은 이번주에 공부할 내용이라 이거는 다음번에 제가 질문하게 된다면 다시 여쭤보고 그때 피드백 드리겠습니다!!

    <br>

---

- ### Q4) 스레드의 장점이 어떤 것들이 있나요

        A)  스레드는 일단 프로세스의 데이터 영역, 코드영역, 힙 영역을 공유해서 컨텍스트 스위치 비용을 낮추는 장점이 있고 렌더링을 할 때, 미리 렌더링을 할 수도 있고 스레드를 분리해서 응답성을 높이는 방식으로 사용자의 경험을 개선할 수 있다.

    #### 정균
  > 잘 답변해주신 것 같아요! 기본 개념과 그게 어떻게 사용되는지 사례를 들어서 말씀해주신것도 좋습니다. 다만, 조금 더 개선할 수 있다면 할 수 있는 사항은 앞에서 프로세스는 각각 독립된 메모리 공간을 가지지만, 스레드는 ~~~ 특징을 가진다. 이렇게 얘기해주시면 아 이사람이 둘의 차이를 정확하게 알고 있구나! 라는 느낌이 들 것 같습니다!!

    <br>

---

- ### Q5) 멀티코어 환경에 대해서 알고 계신가요?

        A)  정확하게는 잘 모르지만, 멀티코어 환경이 CPU를 여러개 배치를 해서 CPU를 여러 개 활용할 수 있는 환경이다.



    <br>

  - ### Q5-1) 그러면 단일 코어 환경과는 뭐가 다르다고 생각하시나요?

          A)  CPU가 여러개 존재 하니깐 멀티프로세스 환경으로 수행할 수 있다고 생각합니다.
            그렇게 해서 프로세스를 여러개 두어서 기존에 단일 프로세스에서 처리할 때는 멀티스레드만 적용을 할 수 있었다면 멀티코어에서는
            멀티프로세스까지 할 수 있다.

#### 정균
  > 멀티코어는 하나의 CPU 칩 안에 여러개의 코어(연산 장치)가 들어 있는 구조를 뜻합니다. 각 코어는 독립적으로 명령어를 실행할 수 있기 때문에, 멀티스레드 프로그램에서 스레드를 병렬로 실행해서 성능을 높일 수 있습니다!!<br>
  단일 코어에서도 멀티 프로세스 실행이 가능은 하지만, 병렬성이 없고 시분할 방식으로 돌아가는 것 뿐입니다.

---

- ### Q6) SJF 알고리즘의 기본인 평균 대기시간이 가장 짧게 되어있는데 왜 실제 OS에서는 SJF를 잘 쓰지 않을까요?

        A)  효율적인 분배와 형평적인 분배도 신경써야 하기때문에 SJF 에서는 작업이 긴 프로세스는 순위가 계속해서 밀리는 기아현상이 발생하기 때문에 현대 운영체제에서는 잘 사용하지 않습니다.

    <br>

  - ### Q6-1) 그러면 현대 운영체제에서는 어떤 스케줄링을 사용하나요?

          A)  멀티큐를 배치해서 스케줄링을 하는 것으로 알고 있습니다.
    <br>


  - ### Q6-2) 멀티큐가 뭐죠?

          A)  기존에 CPU마다 작업큐가 하나만 있었다면, 이번엔 큐를 여러개 두고 큐마다 스케줄링을 다 다르게 해서 하는 걸로 알고 있습니다.
    <br>


  - ### Q6-3) 멀티 레벨 피드백큐 스케줄링 대해서도 알고 계신가요?

          A)  멀티큐에서 파생되어서 기존에 작업큐에서 오버헤드가 발생했을 때..? 이 이상은 잘 모르겠습니다.
    <br>

#### 정균
  > 일단 기본 문제에 대해서는 잘 말씀해주셨습니다!! 거기서 조금 더 보충을 하자면 Starvation 이외에도 구현의 어려움이 있습니다.
  <br>다음 CPU burst 시간을 정확히 예측할 수 없기 때문에 현실적으로 구현이 어렵다는 점도 알아두시면 좋을 것 같습니다. 물론 지수평활법같은 걸 사용해서 알순 있겠지만 이런 것 까진 물어보진 않을 것 같아서,,,<br><br>그리고 6-1 질문부터는 제가 또 따로 드렸는데 답변을 하실 때 현대 운영체제에서는 잘 사용하지 않는다. 라고 답변을 하셨기 때문에 유도하신 것 같아서 질문을 드렸습니다<br>멀티큐도 비슷하긴 하지만 Multi-Level Queue와 헷갈리신 것 같고 실제로 현대 운영체제에서 사용하는건 제가 6-3 질문에서 언금한 Multi-Level-FeedBack Queue 입니다!!<br><br>6-2번에서 말씀해주신 부분은 CPU마다 작업큐가 하나가 있는것이 아니라 Multi-Level Queue 스케줄링에서는 레디큐를 여러개로 나누는 방식을 사용합니다. 실시간 프로세스 용, interactive 프로세스용 큐, 배치 작업용 큐처럼 프로세스 특성이나 우선순위에 따라서 다른 큐에 배치합니다. 그리고 이 각각의 큐가 독립적인 스케줄링 알고리즘을 가질 수 있습니다!! <br><br>마지막의 MLFQ는 멀티레벨 큐와 달리 프로세스가 큐 사이를 이동할 수 있도록 허용하는 방식입니다.
  <br>예를 들어 CPU를 오래 쓰는 프로세스는 점점 낮은 우선순위 큐로 내려가고, I/O bound 프로세스처럼 CPU 사용이 짧은 작업은 상위 큐에 남습니다.
  <br>또, starvation을 막기 위해 오래 기다린 프로세스는 다시 상위 큐로 올려주는 aging 기법도 적용합니다.
---